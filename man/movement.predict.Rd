% Generated by roxygen2 (4.1.1): do not edit by hand
% Please edit documentation in R/movement.R
\name{movement.predict}
\alias{movement.predict}
\title{Use a movement model to predict movements across a landscape.}
\usage{
movement.predict(distance, population, flux = originalRadiationFlux,
  symmetric = FALSE, progress = TRUE, ...)
}
\arguments{
\item{distance}{A distance matrix giving the euclidean distance between
pairs of sites}

\item{population}{A vector giving the population at all sites}

\item{flux}{A flux function (currently either \code{original radiation flux},
\code{radiation with selection flux}, \code{uniform selection flux},
\code{intervening opportunities flux}, \code{gravity flux}
or \code{gravity with distance flux}) used to predict movements}

\item{symmetric}{Whether to calculate symmetric or asymmetric (summed
across both directions) movement}

\item{progress}{Whether to display a progress bar and start and end times
- can be useful for big model runs}

\item{\dots}{Arguments to pass to the flux function}
}
\value{
A (dense) matrix giving predicted movements between all sites
}
\description{
Given a (dense) distance matrix \code{distance} giving the euclidean
distances between all pairs of sites, a vector of population sizes at these
sites \code{population}, use a flux function \code{flux} to predict movement
between all sites.
The model can be calculated either for both directions (by setting
\code{symmetric = FALSE}, resulting in an asymmetric movement matrix) or for
the summed movement between the two (\code{symmetric = TRUE}, giving a
symmetric matrix)). Progress and start and end times can be displayed by
setting \code{progress = TRUE} and arguments of the flux functions can
specified using the \code{dots} argument.
}
\examples{
# generate random coordinates and populations
n <- 30
coords <- matrix(runif(n * 2), ncol = 2)
pop <- round(runif(n) * 1000)
# calculate the distance between pairs of sites
d <- as.matrix(dist(coords))
# predict total movement between them using the radiation model
move <- movement.predict(d, pop, flux = originalRadiationFlux, symmetric = TRUE,
    theta = 0.1)
# plot the points
plot(coords, pch = 16, cex = pop / 500,
     col = 'grey40', axes = FALSE,
     xlab = '', ylab = '')
# and add arrows showing movement
for(i in 2:n) {
  for(j in  (i - 1):n) {
    arrows(coords[i, 1],
           coords[i, 2],
           coords[j, 1],
           coords[j, 2],
           lwd = 2,
           length = 0,
           col = rgb(0, 0, 1, move[i, j] / (max(move) + 1)))
  }
}
}
\seealso{
\code{\link{originalRadiationFlux}}, \code{\link{radiationWithSelectionFlux}},
\code{\link{uniformSelectionFlux}}, \code{\link{interveningOpportunitiesFlux}},
\code{\link{gravityFlux}} and \code{\link{gravityWithDistanceFlux}}
}

